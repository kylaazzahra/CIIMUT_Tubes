# -*- coding: utf-8 -*-
"""Optimasi Pengiriman Logistik pada E-Commerce Menggunakan Algoritma Dynamic Programming, Branch and Bound, dan Greedy

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VUGvoydj2U_dAkUN0TLKJNvmyVX86_ds

Kelas : S1-IF-10-05

Oleh :

Kyla Azzahra Kinan 		2211102225

Hendrik Prayoga 			2211102161

Riftian Dimas Adriano 		2211102138

Muhammad Hatta Rajasa		2211102153

Arif Pramudia Wardana 		2211102149
"""

import pandas as pd  # Mengimpor library pandas untuk manipulasi data

# Membaca file CSV dan menyimpannya dalam DataFrame
data = pd.read_csv('10_DataBarang.csv')  # Menggunakan fungsi read_csv untuk membaca file '10_DataBarang.csv'

data.head() # Menampilkan 5 baris pertama dari DataFrame

"""# n = 10 data"""

import pandas as pd
import time
import heapq
from typing import List, Tuple

# Load data dari file CSV
file_path = '10_DataBarang.csv'
data_barang = pd.read_csv(file_path)

# Menyusun item dari data menjadi list of tuples (id_barang, berat, nilai_barang)
items = list(zip(data_barang['id_barang'], data_barang['berat'], data_barang['nilai_barang']))
capacity = 5000  # Kapasitas maksimum knapsack

# Fungsi untuk menampilkan hasil
def knapsack_result(selected_items: List[str], total_weight: float, total_value: int, runtime: float):
    return {
        "selected_items": selected_items,
        "total_weight": total_weight,
        "total_value": total_value,
        "runtime": runtime
    }

# 1. Dynamic Programming
def knapsack_dp(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    n = len(items)  # Jumlah item
    W = int(capacity)  # Kapasitas knapsack
    weights = [int(item[1]) for item in items]  # List bobot
    values = [item[2] for item in items]  # List nilai
    dp = [[0] * (W + 1) for _ in range(n + 1)]  # Tabel DP untuk menyimpan nilai maksimum

    # Mengisi tabel DP
    for i in range(1, n + 1):
        for w in range(W + 1):
            if weights[i - 1] <= w:  # Jika item dapat dimasukkan
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]  # Item tidak dimasukkan

    # Menelusuri barang yang diambil
    w = W
    selected_items = []
    total_weight = 0  # Inisialisasi total_weight
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i - 1][w]:  # Jika item diambil
            selected_items.append(items[i - 1][0])  # Tambahkan id_barang ke selected_items
            total_weight += weights[i - 1]  # Akumulasi bobot
            w -= weights[i - 1]  # Kurangi kapasitas

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    total_value = dp[n][W]  # Nilai maksimum
    return knapsack_result(selected_items, total_weight, total_value, runtime)

# 2. Branch and Bound
class Node:
    def __init__(self, level, value, weight, bound, selected):
        self.level = level  # Level dalam pohon keputusan
        self.value = value  # Nilai total
        self.weight = weight  # Bobot total
        self.bound = bound  # Batas nilai maksimum
        self.selected = selected  # Item yang dipilih

    def __lt__(self, other):
        return self.bound > other.bound  # Max heap berdasarkan bound

# Fungsi untuk menghitung bound
def bound(node, n, W, weights, values):
    if node.weight >= W:  # Jika bobot melebihi kapasitas
        return 0
    profit_bound = node.value  # Inisialisasi profit_bound
    j = node.level + 1
    total_weight = node.weight
    while j < n and total_weight + weights[j] <= W:  # Tambahkan item ke bound
        total_weight += weights[j]
        profit_bound += values[j]
        j += 1
    if j < n:  # Jika masih ada item yang tersisa
        profit_bound += (W - total_weight) * values[j] / weights[j]  # Tambahkan nilai proporsional
    return profit_bound

def knapsack_branch_and_bound(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    n = len(items)  # Jumlah item
    W = int(capacity)  # Kapasitas knapsack
    weights = [item[1] for item in items]  # List bobot
    values = [item[2] for item in items]  # List nilai
    items_sorted = sorted(enumerate(items), key=lambda x: x[1][2] / x[1][1], reverse=True)  # Urutkan item berdasarkan rasio nilai terhadap bobot
    weights = [items_sorted[i][1][1] for i in range(n)]  # Bobot item yang sudah diurutkan
    values = [items_sorted[i][1][2] for i in range(n)]  # Nilai item yang sudah diurutkan
    ids = [items_sorted[i][1][0] for i in range(n)]  # ID item yang sudah diurutkan

    queue = []  # Antrian untuk menyimpan node
    u = Node(-1, 0, 0, 0.0, [])  # Node awal
    u.bound = bound(u, n, W, weights, values)  # Hitung bound untuk node awal
    max_profit = 0  # Inisialisasi profit maksimum
    best_items = []  # Inisialisasi item terbaik

    heapq.heappush(queue, u)  # Masukkan node awal ke dalam antrian
    while queue:  # Selama antrian tidak kosong
        u = heapq.heappop(queue)  # Ambil node dengan bound tertinggi
        if u.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
            v = Node(u.level + 1, u.value, u.weight, 0.0, u.selected[:])  # Buat node baru
            if v.level < n:  # Jika masih ada item yang tersisa
                v.weight = u.weight + weights[v.level]  # Tambahkan bobot item
                v.value = u.value + values[v.level]  # Tambahkan nilai item
                v.selected = u.selected + [ids[v.level]]  # Tambahkan ID item ke yang dipilih
                if v.weight <= W and v.value > max_profit:  # Jika bobot tidak melebihi kapasitas
                    max_profit = v.value  # Update profit maksimum
                    best_items = v.selected  # Update item terbaik
                v.bound = bound(v, n, W, weights, values)  # Hitung bound untuk node baru
                if v.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
                    heapq.heappush(queue, v)  # Masukkan node baru ke dalam antrian
                v = Node(u.level + 1, u.value, u.weight, 0.0, u.selected[:])  # Buat node baru untuk tidak mengambil item
                v.bound = bound(v, n, W, weights, values)  # Hitung bound
                if v.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
                    heapq.heappush(queue, v)  # Masukkan node baru ke dalam antrian

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    total_weight = sum(items[int(item[3:]) - 1][1] for item in best_items)  # Hitung total bobot item terbaik
    return knapsack_result(best_items, total_weight, max_profit, runtime)  # Kembalikan hasil

# 3. Greedy
def knapsack_greedy(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    W = capacity  # Kapasitas knapsack
    items_sorted = sorted(items, key=lambda x: x[2] / x[1], reverse=True)  # Urutkan berdasarkan rasio nilai terhadap bobot

    total_weight = 0  # Inisialisasi total bobot
    total_value = 0  # Inisialisasi total nilai
    selected_items = []  # Inisialisasi item yang dipilih

    for item in items_sorted:  # Iterasi melalui item yang sudah diurutkan
        if total_weight + item[1] <= W:  # Jika item dapat dimasukkan
            selected_items.append(item[0])  # Tambahkan ID item ke yang dipilih
            total_weight += item[1]  # Akumulasi bobot
            total_value += item[2]  # Akumulasi nilai

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    return knapsack_result(selected_items, total_weight, total_value, runtime)  # Kembalikan hasil

# Menjalankan algoritma
result_dp = knapsack_dp(items, capacity)  # Hasil dari Dynamic Programming
result_bb = knapsack_branch_and_bound(items, capacity)  # Hasil dari Branch and Bound
result_greedy = knapsack_greedy(items, capacity)  # Hasil dari Greedy

def format_result(result):
    formatted = f"Selected Items: {', '.join(result['selected_items'])}\n"  # Format item yang dipilih
    formatted += f"Total Weight: {result['total_weight']}\n"  # Format total bobot
    formatted += f"Total Value: {result['total_value']}\n"  # Format total nilai
    formatted += f"Runtime: {result['runtime']:.6f} seconds\n"  # Format waktu eksekusi
    return formatted

# Menampilkan hasil
print("Ukuran input 10 data")  # Menampilkan ukuran input
print("Kapasitas bobot max : 5000 kg\n")  # Menampilkan kapasitas maksimum
print("Dynamic Programming:\n" + format_result(result_dp))  # Menampilkan hasil Dynamic Programming
print("\nBranch and Bound:\n" + format_result(result_bb))  # Menampilkan hasil Branch and Bound
print("\nGreedy:\n" + format_result(result_greedy))  # Menampilkan hasil Greedy

"""# n = 100 data"""

import pandas as pd
import time
import heapq
from typing import List, Tuple

# Load data dari file CSV
file_path = '100_DataBarang.csv'
data_barang = pd.read_csv(file_path)

# Menyusun item dari data menjadi list of tuples (id_barang, berat, nilai_barang)
items = list(zip(data_barang['id_barang'], data_barang['berat'], data_barang['nilai_barang']))
capacity = 5000  # Kapasitas maksimum knapsack

# Fungsi untuk menampilkan hasil
def knapsack_result(selected_items: List[str], total_weight: float, total_value: int, runtime: float):
    return {
        "selected_items": selected_items,
        "total_weight": total_weight,
        "total_value": total_value,
        "runtime": runtime
    }

# 1. Dynamic Programming
def knapsack_dp(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    n = len(items)  # Jumlah item
    W = int(capacity)  # Kapasitas knapsack
    weights = [int(item[1]) for item in items]  # List bobot
    values = [item[2] for item in items]  # List nilai
    dp = [[0] * (W + 1) for _ in range(n + 1)]  # Tabel DP untuk menyimpan nilai maksimum

    # Mengisi tabel DP
    for i in range(1, n + 1):
        for w in range(W + 1):
            if weights[i - 1] <= w:  # Jika item dapat dimasukkan
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]  # Item tidak dimasukkan

    # Menelusuri barang yang diambil
    w = W
    selected_items = []
    total_weight = 0  # Inisialisasi total_weight
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i - 1][w]:  # Jika item diambil
            selected_items.append(items[i - 1][0])  # Tambahkan id_barang ke selected_items
            total_weight += weights[i - 1]  # Akumulasi bobot
            w -= weights[i - 1]  # Kurangi kapasitas

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    total_value = dp[n][W]  # Nilai maksimum
    return knapsack_result(selected_items, total_weight, total_value, runtime)

# 2. Branch and Bound
class Node:
    def __init__(self, level, value, weight, bound, selected):
        self.level = level  # Level dalam pohon keputusan
        self.value = value  # Nilai total
        self.weight = weight  # Bobot total
        self.bound = bound  # Batas nilai maksimum
        self.selected = selected  # Item yang dipilih

    def __lt__(self, other):
        return self.bound > other.bound  # Max heap berdasarkan bound

# Fungsi untuk menghitung bound
def bound(node, n, W, weights, values):
    if node.weight >= W:  # Jika bobot melebihi kapasitas
        return 0
    profit_bound = node.value  # Inisialisasi profit_bound
    j = node.level + 1
    total_weight = node.weight
    while j < n and total_weight + weights[j] <= W:  # Tambahkan item ke bound
        total_weight += weights[j]
        profit_bound += values[j]
        j += 1
    if j < n:  # Jika masih ada item yang tersisa
        profit_bound += (W - total_weight) * values[j] / weights[j]  # Tambahkan nilai proporsional
    return profit_bound

def knapsack_branch_and_bound(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    n = len(items)  # Jumlah item
    W = int(capacity)  # Kapasitas knapsack
    weights = [item[1] for item in items]  # List bobot
    values = [item[2] for item in items]  # List nilai
    items_sorted = sorted(enumerate(items), key=lambda x: x[1][2] / x[1][1], reverse=True)  # Urutkan item berdasarkan rasio nilai terhadap bobot
    weights = [items_sorted[i][1][1] for i in range(n)]  # Bobot item yang sudah diurutkan
    values = [items_sorted[i][1][2] for i in range(n)]  # Nilai item yang sudah diurutkan
    ids = [items_sorted[i][1][0] for i in range(n)]  # ID item yang sudah diurutkan

    queue = []  # Antrian untuk menyimpan node
    u = Node(-1, 0, 0, 0.0, [])  # Node awal
    u.bound = bound(u, n, W, weights, values)  # Hitung bound untuk node awal
    max_profit = 0  # Inisialisasi profit maksimum
    best_items = []  # Inisialisasi item terbaik

    heapq.heappush(queue, u)  # Masukkan node awal ke dalam antrian
    while queue:  # Selama antrian tidak kosong
        u = heapq.heappop(queue)  # Ambil node dengan bound tertinggi
        if u.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
            v = Node(u.level + 1, u.value, u.weight, 0.0, u.selected[:])  # Buat node baru
            if v.level < n:  # Jika masih ada item yang tersisa
                v.weight = u.weight + weights[v.level]  # Tambahkan bobot item
                v.value = u.value + values[v.level]  # Tambahkan nilai item
                v.selected = u.selected + [ids[v.level]]  # Tambahkan ID item ke yang dipilih
                if v.weight <= W and v.value > max_profit:  # Jika bobot tidak melebihi kapasitas
                    max_profit = v.value  # Update profit maksimum
                    best_items = v.selected  # Update item terbaik
                v.bound = bound(v, n, W, weights, values)  # Hitung bound untuk node baru
                if v.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
                    heapq.heappush(queue, v)  # Masukkan node baru ke dalam antrian
                v = Node(u.level + 1, u.value, u.weight, 0.0, u.selected[:])  # Buat node baru untuk tidak mengambil item
                v.bound = bound(v, n, W, weights, values)  # Hitung bound
                if v.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
                    heapq.heappush(queue, v)  # Masukkan node baru ke dalam antrian

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    total_weight = sum(items[int(item[3:]) - 1][1] for item in best_items)  # Hitung total bobot item terbaik
    return knapsack_result(best_items, total_weight, max_profit, runtime)  # Kembalikan hasil

# 3. Greedy
def knapsack_greedy(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    W = capacity  # Kapasitas knapsack
    items_sorted = sorted(items, key=lambda x: x[2] / x[1], reverse=True)  # Urutkan berdasarkan rasio nilai terhadap bobot

    total_weight = 0  # Inisialisasi total bobot
    total_value = 0  # Inisialisasi total nilai
    selected_items = []  # Inisialisasi item yang dipilih

    for item in items_sorted:  # Iterasi melalui item yang sudah diurutkan
        if total_weight + item[1] <= W:  # Jika item dapat dimasukkan
            selected_items.append(item[0])  # Tambahkan ID item ke yang dipilih
            total_weight += item[1]  # Akumulasi bobot
            total_value += item[2]  # Akumulasi nilai

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    return knapsack_result(selected_items, total_weight, total_value, runtime)  # Kembalikan hasil

# Menjalankan algoritma
result_dp = knapsack_dp(items, capacity)  # Hasil dari Dynamic Programming
result_bb = knapsack_branch_and_bound(items, capacity)  # Hasil dari Branch and Bound
result_greedy = knapsack_greedy(items, capacity)  # Hasil dari Greedy

def format_result(result):
    formatted = f"Selected Items: {', '.join(result['selected_items'])}\n"  # Format item yang dipilih
    formatted += f"Total Weight: {result['total_weight']}\n"  # Format total bobot
    formatted += f"Total Value: {result['total_value']}\n"  # Format total nilai
    formatted += f"Runtime: {result['runtime']:.6f} seconds\n"  # Format waktu eksekusi
    return formatted

# Menampilkan hasil
print("Ukuran input 100 data")  # Menampilkan ukuran input
print("Kapasitas bobot max : 5000 kg\n")  # Menampilkan kapasitas maksimum
print("Dynamic Programming:\n" + format_result(result_dp))  # Menampilkan hasil Dynamic Programming
print("\nBranch and Bound:\n" + format_result(result_bb))  # Menampilkan hasil Branch and Bound
print("\nGreedy:\n" + format_result(result_greedy))  # Menampilkan hasil Greedy

"""# n = 1000 data"""

import pandas as pd
import time
import heapq
from typing import List, Tuple

# Load data dari file CSV
file_path = '1000_DataBarang.csv'
data_barang = pd.read_csv(file_path)

# Menyusun item dari data menjadi list of tuples (id_barang, berat, nilai_barang)
items = list(zip(data_barang['id_barang'], data_barang['berat'], data_barang['nilai_barang']))
capacity = 5000  # Kapasitas maksimum knapsack

# Fungsi untuk menampilkan hasil
def knapsack_result(selected_items: List[str], total_weight: float, total_value: int, runtime: float):
    return {
        "selected_items": selected_items,
        "total_weight": total_weight,
        "total_value": total_value,
        "runtime": runtime
    }

# 1. Dynamic Programming
def knapsack_dp(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    n = len(items)  # Jumlah item
    W = int(capacity)  # Kapasitas knapsack
    weights = [int(item[1]) for item in items]  # List bobot
    values = [item[2] for item in items]  # List nilai
    dp = [[0] * (W + 1) for _ in range(n + 1)]  # Tabel DP untuk menyimpan nilai maksimum

    # Mengisi tabel DP
    for i in range(1, n + 1):
        for w in range(W + 1):
            if weights[i - 1] <= w:  # Jika item dapat dimasukkan
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]  # Item tidak dimasukkan

    # Menelusuri barang yang diambil
    w = W
    selected_items = []
    total_weight = 0  # Inisialisasi total_weight
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i - 1][w]:  # Jika item diambil
            selected_items.append(items[i - 1][0])  # Tambahkan id_barang ke selected_items
            total_weight += weights[i - 1]  # Akumulasi bobot
            w -= weights[i - 1]  # Kurangi kapasitas

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    total_value = dp[n][W]  # Nilai maksimum
    return knapsack_result(selected_items, total_weight, total_value, runtime)

# 2. Branch and Bound
class Node:
    def __init__(self, level, value, weight, bound, selected):
        self.level = level  # Level dalam pohon keputusan
        self.value = value  # Nilai total
        self.weight = weight  # Bobot total
        self.bound = bound  # Batas nilai maksimum
        self.selected = selected  # Item yang dipilih

    def __lt__(self, other):
        return self.bound > other.bound  # Max heap berdasarkan bound

# Fungsi untuk menghitung bound
def bound(node, n, W, weights, values):
    if node.weight >= W:  # Jika bobot melebihi kapasitas
        return 0
    profit_bound = node.value  # Inisialisasi profit_bound
    j = node.level + 1
    total_weight = node.weight
    while j < n and total_weight + weights[j] <= W:  # Tambahkan item ke bound
        total_weight += weights[j]
        profit_bound += values[j]
        j += 1
    if j < n:  # Jika masih ada item yang tersisa
        profit_bound += (W - total_weight) * values[j] / weights[j]  # Tambahkan nilai proporsional
    return profit_bound

def knapsack_branch_and_bound(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    n = len(items)  # Jumlah item
    W = int(capacity)  # Kapasitas knapsack
    weights = [item[1] for item in items]  # List bobot
    values = [item[2] for item in items]  # List nilai
    items_sorted = sorted(enumerate(items), key=lambda x: x[1][2] / x[1][1], reverse=True)  # Urutkan item berdasarkan rasio nilai terhadap bobot
    weights = [items_sorted[i][1][1] for i in range(n)]  # Bobot item yang sudah diurutkan
    values = [items_sorted[i][1][2] for i in range(n)]  # Nilai item yang sudah diurutkan
    ids = [items_sorted[i][1][0] for i in range(n)]  # ID item yang sudah diurutkan

    queue = []  # Antrian untuk menyimpan node
    u = Node(-1, 0, 0, 0.0, [])  # Node awal
    u.bound = bound(u, n, W, weights, values)  # Hitung bound untuk node awal
    max_profit = 0  # Inisialisasi profit maksimum
    best_items = []  # Inisialisasi item terbaik

    heapq.heappush(queue, u)  # Masukkan node awal ke dalam antrian
    while queue:  # Selama antrian tidak kosong
        u = heapq.heappop(queue)  # Ambil node dengan bound tertinggi
        if u.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
            v = Node(u.level + 1, u.value, u.weight, 0.0, u.selected[:])  # Buat node baru
            if v.level < n:  # Jika masih ada item yang tersisa
                v.weight = u.weight + weights[v.level]  # Tambahkan bobot item
                v.value = u.value + values[v.level]  # Tambahkan nilai item
                v.selected = u.selected + [ids[v.level]]  # Tambahkan ID item ke yang dipilih
                if v.weight <= W and v.value > max_profit:  # Jika bobot tidak melebihi kapasitas
                    max_profit = v.value  # Update profit maksimum
                    best_items = v.selected  # Update item terbaik
                v.bound = bound(v, n, W, weights, values)  # Hitung bound untuk node baru
                if v.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
                    heapq.heappush(queue, v)  # Masukkan node baru ke dalam antrian
                v = Node(u.level + 1, u.value, u.weight, 0.0, u.selected[:])  # Buat node baru untuk tidak mengambil item
                v.bound = bound(v, n, W, weights, values)  # Hitung bound
                if v.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
                    heapq.heappush(queue, v)  # Masukkan node baru ke dalam antrian

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    total_weight = sum(items[int(item[3:]) - 1][1] for item in best_items)  # Hitung total bobot item terbaik
    return knapsack_result(best_items, total_weight, max_profit, runtime)  # Kembalikan hasil

# 3. Greedy
def knapsack_greedy(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    W = capacity  # Kapasitas knapsack
    items_sorted = sorted(items, key=lambda x: x[2] / x[1], reverse=True)  # Urutkan berdasarkan rasio nilai terhadap bobot

    total_weight = 0  # Inisialisasi total bobot
    total_value = 0  # Inisialisasi total nilai
    selected_items = []  # Inisialisasi item yang dipilih

    for item in items_sorted:  # Iterasi melalui item yang sudah diurutkan
        if total_weight + item[1] <= W:  # Jika item dapat dimasukkan
            selected_items.append(item[0])  # Tambahkan ID item ke yang dipilih
            total_weight += item[1]  # Akumulasi bobot
            total_value += item[2]  # Akumulasi nilai

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    return knapsack_result(selected_items, total_weight, total_value, runtime)  # Kembalikan hasil

# Menjalankan algoritma
result_dp = knapsack_dp(items, capacity)  # Hasil dari Dynamic Programming
result_bb = knapsack_branch_and_bound(items, capacity)  # Hasil dari Branch and Bound
result_greedy = knapsack_greedy(items, capacity)  # Hasil dari Greedy

def format_result(result):
    formatted = f"Selected Items: {', '.join(result['selected_items'])}\n"  # Format item yang dipilih
    formatted += f"Total Weight: {result['total_weight']}\n"  # Format total bobot
    formatted += f"Total Value: {result['total_value']}\n"  # Format total nilai
    formatted += f"Runtime: {result['runtime']:.6f} seconds\n"  # Format waktu eksekusi
    return formatted

# Menampilkan hasil
print("Ukuran input 1000 data")  # Menampilkan ukuran input
print("Kapasitas bobot max : 5000 kg\n")  # Menampilkan kapasitas maksimum
print("Dynamic Programming:\n" + format_result(result_dp))  # Menampilkan hasil Dynamic Programming
print("\nBranch and Bound:\n" + format_result(result_bb))  # Menampilkan hasil Branch and Bound
print("\nGreedy:\n" + format_result(result_greedy))  # Menampilkan hasil Greedy

"""# n = 5000 data"""

import pandas as pd
import time
import heapq
from typing import List, Tuple

# Load data dari file CSV
file_path = '5000_DataBarang.csv'
data_barang = pd.read_csv(file_path)

# Menyusun item dari data menjadi list of tuples (id_barang, berat, nilai_barang)
items = list(zip(data_barang['id_barang'], data_barang['berat'], data_barang['nilai_barang']))
capacity = 5000  # Kapasitas maksimum knapsack

# Fungsi untuk menampilkan hasil
def knapsack_result(selected_items: List[str], total_weight: float, total_value: int, runtime: float):
    return {
        "selected_items": selected_items,
        "total_weight": total_weight,
        "total_value": total_value,
        "runtime": runtime
    }

# 1. Dynamic Programming
def knapsack_dp(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    n = len(items)  # Jumlah item
    W = int(capacity)  # Kapasitas knapsack
    weights = [int(item[1]) for item in items]  # List bobot
    values = [item[2] for item in items]  # List nilai
    dp = [[0] * (W + 1) for _ in range(n + 1)]  # Tabel DP untuk menyimpan nilai maksimum

    # Mengisi tabel DP
    for i in range(1, n + 1):
        for w in range(W + 1):
            if weights[i - 1] <= w:  # Jika item dapat dimasukkan
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]  # Item tidak dimasukkan

    # Menelusuri barang yang diambil
    w = W
    selected_items = []
    total_weight = 0  # Inisialisasi total_weight
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i - 1][w]:  # Jika item diambil
            selected_items.append(items[i - 1][0])  # Tambahkan id_barang ke selected_items
            total_weight += weights[i - 1]  # Akumulasi bobot
            w -= weights[i - 1]  # Kurangi kapasitas

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    total_value = dp[n][W]  # Nilai maksimum
    return knapsack_result(selected_items, total_weight, total_value, runtime)

# 2. Branch and Bound
class Node:
    def __init__(self, level, value, weight, bound, selected):
        self.level = level  # Level dalam pohon keputusan
        self.value = value  # Nilai total
        self.weight = weight  # Bobot total
        self.bound = bound  # Batas nilai maksimum
        self.selected = selected  # Item yang dipilih

    def __lt__(self, other):
        return self.bound > other.bound  # Max heap berdasarkan bound

# Fungsi untuk menghitung bound
def bound(node, n, W, weights, values):
    if node.weight >= W:  # Jika bobot melebihi kapasitas
        return 0
    profit_bound = node.value  # Inisialisasi profit_bound
    j = node.level + 1
    total_weight = node.weight
    while j < n and total_weight + weights[j] <= W:  # Tambahkan item ke bound
        total_weight += weights[j]
        profit_bound += values[j]
        j += 1
    if j < n:  # Jika masih ada item yang tersisa
        profit_bound += (W - total_weight) * values[j] / weights[j]  # Tambahkan nilai proporsional
    return profit_bound

def knapsack_branch_and_bound(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    n = len(items)  # Jumlah item
    W = int(capacity)  # Kapasitas knapsack
    weights = [item[1] for item in items]  # List bobot
    values = [item[2] for item in items]  # List nilai
    items_sorted = sorted(enumerate(items), key=lambda x: x[1][2] / x[1][1], reverse=True)  # Urutkan item berdasarkan rasio nilai terhadap bobot
    weights = [items_sorted[i][1][1] for i in range(n)]  # Bobot item yang sudah diurutkan
    values = [items_sorted[i][1][2] for i in range(n)]  # Nilai item yang sudah diurutkan
    ids = [items_sorted[i][1][0] for i in range(n)]  # ID item yang sudah diurutkan

    queue = []  # Antrian untuk menyimpan node
    u = Node(-1, 0, 0, 0.0, [])  # Node awal
    u.bound = bound(u, n, W, weights, values)  # Hitung bound untuk node awal
    max_profit = 0  # Inisialisasi profit maksimum
    best_items = []  # Inisialisasi item terbaik

    heapq.heappush(queue, u)  # Masukkan node awal ke dalam antrian
    while queue:  # Selama antrian tidak kosong
        u = heapq.heappop(queue)  # Ambil node dengan bound tertinggi
        if u.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
            v = Node(u.level + 1, u.value, u.weight, 0.0, u.selected[:])  # Buat node baru
            if v.level < n:  # Jika masih ada item yang tersisa
                v.weight = u.weight + weights[v.level]  # Tambahkan bobot item
                v.value = u.value + values[v.level]  # Tambahkan nilai item
                v.selected = u.selected + [ids[v.level]]  # Tambahkan ID item ke yang dipilih
                if v.weight <= W and v.value > max_profit:  # Jika bobot tidak melebihi kapasitas
                    max_profit = v.value  # Update profit maksimum
                    best_items = v.selected  # Update item terbaik
                v.bound = bound(v, n, W, weights, values)  # Hitung bound untuk node baru
                if v.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
                    heapq.heappush(queue, v)  # Masukkan node baru ke dalam antrian
                v = Node(u.level + 1, u.value, u.weight, 0.0, u.selected[:])  # Buat node baru untuk tidak mengambil item
                v.bound = bound(v, n, W, weights, values)  # Hitung bound
                if v.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
                    heapq.heappush(queue, v)  # Masukkan node baru ke dalam antrian

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    total_weight = sum(items[int(item[3:]) - 1][1] for item in best_items)  # Hitung total bobot item terbaik
    return knapsack_result(best_items, total_weight, max_profit, runtime)  # Kembalikan hasil

# 3. Greedy
def knapsack_greedy(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    W = capacity  # Kapasitas knapsack
    items_sorted = sorted(items, key=lambda x: x[2] / x[1], reverse=True)  # Urutkan berdasarkan rasio nilai terhadap bobot

    total_weight = 0  # Inisialisasi total bobot
    total_value = 0  # Inisialisasi total nilai
    selected_items = []  # Inisialisasi item yang dipilih

    for item in items_sorted:  # Iterasi melalui item yang sudah diurutkan
        if total_weight + item[1] <= W:  # Jika item dapat dimasukkan
            selected_items.append(item[0])  # Tambahkan ID item ke yang dipilih
            total_weight += item[1]  # Akumulasi bobot
            total_value += item[2]  # Akumulasi nilai

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    return knapsack_result(selected_items, total_weight, total_value, runtime)  # Kembalikan hasil

# Menjalankan algoritma
result_dp = knapsack_dp(items, capacity)  # Hasil dari Dynamic Programming
result_bb = knapsack_branch_and_bound(items, capacity)  # Hasil dari Branch and Bound
result_greedy = knapsack_greedy(items, capacity)  # Hasil dari Greedy

def format_result(result):
    formatted = f"Selected Items: {', '.join(result['selected_items'])}\n"  # Format item yang dipilih
    formatted += f"Total Weight: {result['total_weight']}\n"  # Format total bobot
    formatted += f"Total Value: {result['total_value']}\n"  # Format total nilai
    formatted += f"Runtime: {result['runtime']:.6f} seconds\n"  # Format waktu eksekusi
    return formatted

# Menampilkan hasil
print("Ukuran input 5000 data")  # Menampilkan ukuran input
print("Kapasitas bobot max : 5000 kg\n")  # Menampilkan kapasitas maksimum
print("Dynamic Programming:\n" + format_result(result_dp))  # Menampilkan hasil Dynamic Programming
print("\nBranch and Bound:\n" + format_result(result_bb))  # Menampilkan hasil Branch and Bound
print("\nGreedy:\n" + format_result(result_greedy))  # Menampilkan hasil Greedy

"""# n = 10000 data"""

import pandas as pd
import time
import heapq
from typing import List, Tuple

# Load data dari file CSV
file_path = '10000_DataBarang.csv'
data_barang = pd.read_csv(file_path)

# Menyusun item dari data menjadi list of tuples (id_barang, berat, nilai_barang)
items = list(zip(data_barang['id_barang'], data_barang['berat'], data_barang['nilai_barang']))
capacity = 5000  # Kapasitas maksimum knapsack

# Fungsi untuk menampilkan hasil
def knapsack_result(selected_items: List[str], total_weight: float, total_value: int, runtime: float):
    return {
        "selected_items": selected_items,
        "total_weight": total_weight,
        "total_value": total_value,
        "runtime": runtime
    }

# 1. Dynamic Programming
def knapsack_dp(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    n = len(items)  # Jumlah item
    W = int(capacity)  # Kapasitas knapsack
    weights = [int(item[1]) for item in items]  # List bobot
    values = [item[2] for item in items]  # List nilai
    dp = [[0] * (W + 1) for _ in range(n + 1)]  # Tabel DP untuk menyimpan nilai maksimum

    # Mengisi tabel DP
    for i in range(1, n + 1):
        for w in range(W + 1):
            if weights[i - 1] <= w:  # Jika item dapat dimasukkan
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1])
            else:
                dp[i][w] = dp[i - 1][w]  # Item tidak dimasukkan

    # Menelusuri barang yang diambil
    w = W
    selected_items = []
    total_weight = 0  # Inisialisasi total_weight
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i - 1][w]:  # Jika item diambil
            selected_items.append(items[i - 1][0])  # Tambahkan id_barang ke selected_items
            total_weight += weights[i - 1]  # Akumulasi bobot
            w -= weights[i - 1]  # Kurangi kapasitas

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    total_value = dp[n][W]  # Nilai maksimum
    return knapsack_result(selected_items, total_weight, total_value, runtime)

# 2. Branch and Bound
class Node:
    def __init__(self, level, value, weight, bound, selected):
        self.level = level  # Level dalam pohon keputusan
        self.value = value  # Nilai total
        self.weight = weight  # Bobot total
        self.bound = bound  # Batas nilai maksimum
        self.selected = selected  # Item yang dipilih

    def __lt__(self, other):
        return self.bound > other.bound  # Max heap berdasarkan bound

# Fungsi untuk menghitung bound
def bound(node, n, W, weights, values):
    if node.weight >= W:  # Jika bobot melebihi kapasitas
        return 0
    profit_bound = node.value  # Inisialisasi profit_bound
    j = node.level + 1
    total_weight = node.weight
    while j < n and total_weight + weights[j] <= W:  # Tambahkan item ke bound
        total_weight += weights[j]
        profit_bound += values[j]
        j += 1
    if j < n:  # Jika masih ada item yang tersisa
        profit_bound += (W - total_weight) * values[j] / weights[j]  # Tambahkan nilai proporsional
    return profit_bound

def knapsack_branch_and_bound(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    n = len(items)  # Jumlah item
    W = int(capacity)  # Kapasitas knapsack
    weights = [item[1] for item in items]  # List bobot
    values = [item[2] for item in items]  # List nilai
    items_sorted = sorted(enumerate(items), key=lambda x: x[1][2] / x[1][1], reverse=True)  # Urutkan item berdasarkan rasio nilai terhadap bobot
    weights = [items_sorted[i][1][1] for i in range(n)]  # Bobot item yang sudah diurutkan
    values = [items_sorted[i][1][2] for i in range(n)]  # Nilai item yang sudah diurutkan
    ids = [items_sorted[i][1][0] for i in range(n)]  # ID item yang sudah diurutkan

    queue = []  # Antrian untuk menyimpan node
    u = Node(-1, 0, 0, 0.0, [])  # Node awal
    u.bound = bound(u, n, W, weights, values)  # Hitung bound untuk node awal
    max_profit = 0  # Inisialisasi profit maksimum
    best_items = []  # Inisialisasi item terbaik

    heapq.heappush(queue, u)  # Masukkan node awal ke dalam antrian
    while queue:  # Selama antrian tidak kosong
        u = heapq.heappop(queue)  # Ambil node dengan bound tertinggi
        if u.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
            v = Node(u.level + 1, u.value, u.weight, 0.0, u.selected[:])  # Buat node baru
            if v.level < n:  # Jika masih ada item yang tersisa
                v.weight = u.weight + weights[v.level]  # Tambahkan bobot item
                v.value = u.value + values[v.level]  # Tambahkan nilai item
                v.selected = u.selected + [ids[v.level]]  # Tambahkan ID item ke yang dipilih
                if v.weight <= W and v.value > max_profit:  # Jika bobot tidak melebihi kapasitas
                    max_profit = v.value  # Update profit maksimum
                    best_items = v.selected  # Update item terbaik
                v.bound = bound(v, n, W, weights, values)  # Hitung bound untuk node baru
                if v.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
                    heapq.heappush(queue, v)  # Masukkan node baru ke dalam antrian
                v = Node(u.level + 1, u.value, u.weight, 0.0, u.selected[:])  # Buat node baru untuk tidak mengambil item
                v.bound = bound(v, n, W, weights, values)  # Hitung bound
                if v.bound > max_profit:  # Jika bound lebih besar dari profit maksimum
                    heapq.heappush(queue, v)  # Masukkan node baru ke dalam antrian

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    total_weight = sum(items[int(item[3:]) - 1][1] for item in best_items)  # Hitung total bobot item terbaik
    return knapsack_result(best_items, total_weight, max_profit, runtime)  # Kembalikan hasil

# 3. Greedy
def knapsack_greedy(items: List[Tuple[str, float, int]], capacity: float):
    start_time = time.time()  # Mulai pengukuran waktu
    W = capacity  # Kapasitas knapsack
    items_sorted = sorted(items, key=lambda x: x[2] / x[1], reverse=True)  # Urutkan berdasarkan rasio nilai terhadap bobot

    total_weight = 0  # Inisialisasi total bobot
    total_value = 0  # Inisialisasi total nilai
    selected_items = []  # Inisialisasi item yang dipilih

    for item in items_sorted:  # Iterasi melalui item yang sudah diurutkan
        if total_weight + item[1] <= W:  # Jika item dapat dimasukkan
            selected_items.append(item[0])  # Tambahkan ID item ke yang dipilih
            total_weight += item[1]  # Akumulasi bobot
            total_value += item[2]  # Akumulasi nilai

    runtime = time.time() - start_time  # Hitung waktu eksekusi
    return knapsack_result(selected_items, total_weight, total_value, runtime)  # Kembalikan hasil

# Menjalankan algoritma
result_dp = knapsack_dp(items, capacity)  # Hasil dari Dynamic Programming
result_bb = knapsack_branch_and_bound(items, capacity)  # Hasil dari Branch and Bound
result_greedy = knapsack_greedy(items, capacity)  # Hasil dari Greedy

def format_result(result):
    formatted = f"Selected Items: {', '.join(result['selected_items'])}\n"  # Format item yang dipilih
    formatted += f"Total Weight: {result['total_weight']}\n"  # Format total bobot
    formatted += f"Total Value: {result['total_value']}\n"  # Format total nilai
    formatted += f"Runtime: {result['runtime']:.6f} seconds\n"  # Format waktu eksekusi
    return formatted

# Menampilkan hasil
print("Ukuran input 10000 data")  # Menampilkan ukuran input
print("Kapasitas bobot max : 5000 kg\n")  # Menampilkan kapasitas maksimum
print("Dynamic Programming:\n" + format_result(result_dp))  # Menampilkan hasil Dynamic Programming
print("\nBranch and Bound:\n" + format_result(result_bb))  # Menampilkan hasil Branch and Bound
print("\nGreedy:\n" + format_result(result_greedy))  # Menampilkan hasil Greedy

import matplotlib.pyplot as plt  # Mengimpor library matplotlib untuk visualisasi data

# Data untuk ukuran input (n) dan waktu eksekusi (t) untuk masing-masing algoritma
input_sizes = [10, 100, 1000, 5000, 10000]  # Ukuran input yang digunakan dalam algoritma

# Waktu eksekusi untuk masing-masing algoritma
dp_times = [0.025598, 0.265003, 4.511589, 16.456330, 35.500866]  # Waktu eksekusi untuk Dynamic Programming
bb_times = [0.000125, 0.002870, 0.261823, 1.107481, 1.117179]      # Waktu eksekusi untuk Branch and Bound
greedy_times = [0.000009, 0.000049, 0.000900, 0.004324, 0.004783] # Waktu eksekusi untuk Greedy

# Membuat grafik
plt.figure(figsize=(10, 6))  # Mengatur ukuran figure grafik

# Plot untuk Dynamic Programming
plt.plot(input_sizes, dp_times, marker='o', label='Dynamic Programming', color='blue')  # Menggambar garis untuk DP

# Plot untuk Branch and Bound
plt.plot(input_sizes, bb_times, marker='o', label='Branch and Bound', color='orange')  # Menggambar garis untuk BB

# Plot untuk Greedy
plt.plot(input_sizes, greedy_times, marker='o', label='Greedy', color='green')  # Menggambar garis untuk Greedy

# Menambahkan judul dan label
plt.title('Running Time vs Input Size')  # Menambahkan judul grafik
plt.xlabel('Input Size (n)')  # Menambahkan label sumbu x
plt.ylabel('Running Time (seconds)')  # Menambahkan label sumbu y
plt.xscale('log')  # Menggunakan skala logaritmik untuk sumbu x agar lebih mudah dibaca
plt.yscale('log')  # Menggunakan skala logaritmik untuk sumbu y agar perbandingan waktu lebih jelas
plt.grid(True, which='both', linestyle='--', linewidth=0.5)  # Menambahkan grid pada grafik
plt.legend()  # Menampilkan legenda untuk membedakan algoritma
plt.tight_layout()  # Mengatur layout agar lebih rapi

# Menampilkan grafik
plt.show()  # Menampilkan grafik yang telah dibuat

"""# Kesimpulan

Berdasarkan analisis total nilai, total bobot, dan waktu eksekusi dari setiap algoritma (Dynamic Programming, Branch and Bound, dan Greedy) pada berbagai ukuran input, dapat disimpulkan bahwa:

1. Total Value: Algoritma Dynamic Programming menunjukkan total nilai tertinggi di semua ukuran input, mencapai 705975852 pada ukuran input 10000 data. Sementara itu, algoritma Branch and Bound dan Greedy menghasilkan nilai yang sedikit lebih rendah, dengan nilai maksimum masing-masing 640500242 dan 640484456 pada ukuran input yang sama. Hal ini menunjukkan bahwa Dynamic Programming lebih efektif dalam memaksimalkan nilai total barang yang dapat dimasukkan ke dalam kapasitas maksimum.

2. Total Weight: Dynamic Programming tidak hanya mencapai total nilai tertinggi, tetapi juga total bobot yang paling tepat, yaitu 5000 kg pada ukuran input 1000 data dan seterusnya. Algoritma ini berhasil memanfaatkan kapasitas maksimum dengan efisien. Sementara itu, Branch and Bound dan Greedy juga mencapai total bobot yang mendekati kapasitas maksimum, tetapi Dynamic Programming lebih konsisten dalam mencapai bobot yang tepat.

3. Running Time: Dari segi waktu eksekusi, algoritma Greedy menunjukkan performa tercepat di semua ukuran input, dengan waktu eksekusi yang sangat rendah, bahkan di bawah satu milidetik untuk ukuran input kecil. Branch and Bound juga menunjukkan waktu eksekusi yang efisien, terutama pada ukuran input yang lebih besar, dengan waktu di bawah 3 milidetik untuk ukuran input 1000 data. Sebaliknya, Dynamic Programming, meskipun memberikan hasil terbaik dalam hal nilai total, memiliki waktu eksekusi yang lebih lama, terutama pada ukuran input yang lebih besar, mencapai lebih dari 35 detik untuk 10000 data. Ini menunjukkan bahwa meskipun Dynamic Programming lebih optimal dalam hal nilai, ia memerlukan waktu komputasi yang lebih lama dibandingkan dengan algoritma lainnya.
"""